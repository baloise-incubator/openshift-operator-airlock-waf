= openshift-operator-airlock-waf

== workflow(s)

image::http://www.plantuml.com/plantuml/proxy?src=https://raw.github.com/baloise-incubator/openshift-operator-airlock-waf/master/workflow.puml[workflow]

== metadata

=== ideas

We've discussed two ideas

- defining a https://docs.okd.io/3.11/admin_guide/custom_resource_definitions.html[CustomResourceDefinitions (CRD)] and listend for change events here
- listening for e.g. route - see https://docs.okd.io/3.11/architecture/networking/routes.html[architecture] and https://docs.okd.io/3.11/rest_api/route_openshift_io/route-route-openshift-io-v1.html[API] - change events and https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/[annotation] the e.g. route with required information to create / update / maintain a WAF mapping

For now we go with the second approach.

=== WAF -> OpenShift attribute & annotation mapping

[source,yaml]
----
  metadata:
    annotations:
      baloise.com/waf-operator-enabled: "true|false"                        # <1>
      baloise.com/waf-mapping-name: "<mapping-name>"                        # <2>
      baloise.com/waf-mapping-entry-path: "<mapping-entry-path>"            # <3>
      baloise.com/waf-mapping-backend-path: "<mapping-backend-path>"        # <4>
      baloise.com/waf-backendgroup-name: "<backendgroup-name>"              # <5>
      baloise.com/waf-backend-name: "<backend-name>"                        # <6>
      baloise.com/waf-backend-protocol: "<backend-protocol: https>"         # <7>
      baloise.com/waf-backend-port: "<backend-port: 443"                    # <8>
      baloise.com/waf-vhost-name: "<vhost-name: 443"                        # <9>
----
<1> 
<2> 
<3> 
<4> 
<5> 
<6> 
<7> 
<8> 
<9> 

### example
[source,yaml]
----
  metadata:
    annotations:
      baloise.com/waf-operator-enabled: "true"
      baloise.com/waf-mapping-name: "echoserver"
      baloise.com/waf-mapping-entry-path: "/"
      baloise.com/waf-mapping-backend-path: "/"
      baloise.com/waf-backendgroup-name: "echoserver-group"
      baloise.com/waf-backend-name: "echoserver-test.demodomain.com"
      baloise.com/waf-backend-protocol: "https"
      baloise.com/waf-backend-port: "443"
      baloise.com/waf-vhost-name: "CodeCamp WAF1"
----

=== https://docs.airlock.com/gateway/7.4/rest-api/config-rest-api.html[-> WAF Configuration REST API]

== approach 1

=== idea

use and contribute: https://github.com/ergon/airlock-waf-kubernetes-openshift-integration

=== https://en.wikipedia.org/wiki/SWOT_analysis#Overview[SWOT] ergon

[cols="1,1", options="header"] 
|===
| Strengths 
| Weaknesses

| based on Spring

based on manufacturer know-how

modularized

in sync with manufacturer (API) changes

| partially reliant on https://github.com/ergon/airlock-waf-kubernetes-openshift-integration/issues/8[internal / binary resources]

| *Opportunities*
| *Threats*

| (distributed) maintenance (e.g. by manufacturer) in future
| upstream project direction no longer aligned with internal requirements

mitigation: *https://github.com/baloise-incubator/airlock-waf-kubernetes-openshift-integration[fork] and maintain on our own*
|===

== approach 2 

=== idea

champion: build our own (lightweight) solution based on Quarkus and the Fabric8 Java Kubernetes client API.

=== https://en.wikipedia.org/wiki/SWOT_analysis#Overview[SWOT] baloise

[cols="1,1", options="header"] 
|===
| Strengths 
| Weaknesses

| potentially more lightweight

exactly what we need

| offset to manufacturer (API) changes

(new) use cases must be implemented and maintained by our own

| *Opportunities*
| *Threats*

| exemplify new technology within small and well defined scope
| new framework technology without TIP & supporter

mitigation: *find supporter and file TIP*

incompatible (API) changes by manufacturer

mitigation: *make open-source and inform manufacturer about it*

|===
